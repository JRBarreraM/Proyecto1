#
# Juego4enLineaEquipo07.gcl
#
# DESCRIPCION: algoritmo que permite a un usuario jugar al 4 en linea \
# contra una IA con 2 niveles de dificultad (facil y medio), a traves de la \
# terminal de la interfaz grafica.
#
# Autores: 
#	Br. Jose Barrera y Alfredo Cruz.
#
# Ultima modificacion: 16/03/2018.

[
   CONS					# las constantes nos ayudan a tener la informacion que no
   	nombre : str;			# podemos pedir al usuario, su nombre, la dificultad, 
	nivel : int;			# si desea abandonar una partida, si desea salir del programa,
	rendirse : bool;		# y por supuesto la jugada que hara en cada turno reflejada en
	irse : bool;			# sus coordenadas fila, columna.
	x : int;
	y : int;
	N : int;			# Numero de filas 	# estas son las verdaderas constantes del programa
	M : int;			# Numero de columnas
   VAR
	A : array [0..N)x[0..M) of int;		# el tablero de juego
	jugando : bool;				# en partida
	turno : int;				# contador de los turnos 
	juega : int;				# a quien le toca jugar(True para user, False para IA)
	ganador : int;				# el primero en cumplir las condiciones
	dentro : bool;				# dentro del programa
	movida : bool;				# permite reintentar hasta hacer una jugada
	i : int;				# fila jugada de la IA 
	j : int;				# columna jugada de la IA
	partida : int; 				# numero de partidas jugadas en sesion actual
	 
	{ N = 6 /\ M = 7 }
		jugando,turno,ganador,juega,dentro,partida:=False,1,0,True,True,1;
		
		{bound 43 - turno}
		
		do ¬jugando /\ dentro ->					#en menu
			resultados( ganador );
			terminar( irse );
			if nuevapartida( decision , partida )->
				Inicio(A);
		
		[] jugando /\ dentro ->						#en partida
			if turno = 42 ->
				jugando:=False;
			[] turno < 42 ->
				if juega ->
					abandonar(rendirse);
					jugadaUser(A,x,y);
				[] ¬juega ->
					if nivel = 1 ->
						movida:=True;
						do movida->
							i:=random.randrange(6);
							j:=random.randrange(7);
							if valida(A,i,j) ->
								A[i][j] := 2;
								movida := False;
							[] not valida(A,i,j) ->
								skip;
							fi;
						od
						victoria(A,i,j);
					[] nivel = 2 ->
						if turno=1 \/ turno=2 ->
							if valida(5,3)->
								A[5][3]:=2
								i,j:=5,3;
							[] not valida(5,3)->
								A[5][2]:=2
								i,j:=5,2;
							fi;
						[] turno > 2 ->
							IA(A,i,j);
							victoria(A,i,j);
						fi
					fi
				turno := turno+1
				juega := ¬juega
				fi
			fi;
		od
   { dentro = False }
]

#Aqui termina el esqueleto del programa, de aqui en adelante se colocan
# todos los procedimientos que llama.

proc jugadaUser(  in x : int ; in y : int ; in-out : A : array [0..6)x[0..7) of int)  
{ Pre: True }
{ Post:  (valida(x,y)=1 => A[x][y] = 1]) /\ (valida(x,y)=0 => A[x][y] = 0) }
[
	VAR
		ganador : int;
		jugando : bool;

		ganador := 0;
		jugando := False;
		
		do 		
			if valida(x,y) ->
				A[x][y] := 1;
				victoria(A,x,y); 
			[] not valida(i,j) ->			#se pide al usuario que intente otra jugada
				skip;
		od		
]

# Esta es la funcion valida una de las funciones mas importantes del programa, sin importar
# si la coordenada esta o no en el tablero (la matriz A), nos dice si la jugada es valida
func valida( A : array [0..6)x[0..7); i,j : int ) -> bool
{ Pre: True }
{ Post: valida=((A[i][j]=0)/\i=5)\/((A[i][j]=0)/\i<5/\A[i-1][j]!=0)}
[
	VAR
	valida : bool;
	
	if 0 <= i < 6 /\ 0 <= j < 7 ->
		if A[i][j]=0 ->
			if i=5 ->
				valida:=True;
			[] i<5 /\ A[i+1][j]!=0 ->
				valida:=True;
			[] i<5 /\ A[i+1][j]=0 ->
				valida:=False;
			fi
		[] A[i][j]!=0 ->
			valida:=False;
		fi
	[] i < 0 \/ i > 5 \/ j < 0 \/ j > 6 ->
		valida:=False;
	fi

	>> valida
]
		
proc victoria(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool)
{ Pre: True  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[

	victoriahorizontal(A,i,j);

	if jugando ->
		victoriavertical(A,i,j);
		if jugando ->
			victoriadiagonalprincipal(A,i,j);
			if jugando ->
				victoriadiagonalsecundaria(A,i,j)
			[] ¬jugando ->
				skip
		[] ¬jugando ->
			skip
		fi
	[] ¬jugando ->
		skip
	fi
]
#Aqui se verifican las distintas condiciones para que un jugador gane el juego formando 4 en raya.
proc victoriadiagonalprincipal(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=False) \/ ((ganador=1 \/ ganador=2)/\(jugando=False)) }
[
	VAR
    	ganador : int;
		jugando : bool;
		i : int;
		j : int;

	jugando := True;

	i:=0;
	{bound 6-i}
	do i < 3 ->
		j:=0;
		{bound 4-j}
		do j < 4 /\ jugando=True ->
			#Conexion diagonal principal
			if A[i][j]=A[i+1][j+1]=A[i+2][j+2]=A[i+3][j+3]=1 ->
				ganador:=1;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			
			[] A[i][j]=A[i+1][j+1]=A[i+2][j+2]=A[i+3][j+3]=2 ->
				ganador:=2;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi
			j:=j+1;
		od;
		i:=i+1;
	od;
]

proc victoriahorizontal( in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=False) \/ ((ganador=1 \/ ganador=2)/\(jugando=False)) }
[
	VAR
    	ganador : int;
		jugando : bool;
		i : int;
		j : int;

	jugando,i := True,0;

	{bound 6-i}
	do i<6->
		j:=0;
		{bound 4-j}
		do j<4 /\ jugando=True->
			#Conexion horizontal
			if A[i][j]=A[i][j+1]=A[i][j+2]=A[i][j+3]=1 ->
				ganador:=1;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			[] A[i][j]=A[i][j+1]=A[i][j+2]=A[i][j+3]=2 ->
				ganador:=2;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi
			j:=j+1;
		od
		i:=i+1;
	od
]

proc victoriavertical(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=False) \/ ((ganador=1 \/ ganador=2)/\(jugando=False)) }
[
	VAR
    	ganador : int;
		jugando : bool;
		i : int;
		j : int;

	jugando, i := True,0;

	{bound 3-i}
	do i < 3 ->
		j:=0;
		{bound 7-j}
		do j < 7 /\ jugando=True ->
			if A[i][j]=A[i+1][j]=A[i+2][j]=A[i+3][j]=1 ->
				ganador:=1;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			[] A[i][j]=A[i+1][j]=A[i+2][j]=A[i+3][j]=2 ->
				ganador:=2;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi;
			j:=j+1;
		od
		i:=i+1;
	od
]

proc victoriadiagonalsecundaria(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post: (ganador=0 /\ jugando=False) \/ ((ganador=1 \/ ganador=2)/\(jugando=False)) }
[
	VAR
    	ganador : int;
		jugando : bool;
		i : int;
		j : int;

	jugando, i := True, 0;

	{bound 3-i}
	do i < 3 ->
		j:=0;
		{bound 7-j}
		do j < 7 /\ jugando=True ->
			#Conexion diagonal secundaria
			if j>2 /\ A[i][j]=A[i+1][j-1]=A[i+2][j-2]=A[i+3][j-3]=1 ->
				ganador:=1;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			[] j>2 /\ A[i][j]=A[i+1][j-1]=A[i+2][j-2]=A[i+3][j-3]=2 ->
				ganador:=2;
				jugando:=False;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			fi;
			j:=j+1;
		od
		i:=i+1;
	od
]
# Aqui culminan las verificaciones de las posibilidades de ganar el juego con un 4 en raya.

proc Inicio(in-out A: array [0..6)x[0..7) of int) 			#tambien arroja el nombre y la dificultad
{Pre: True}
{Post: (%forall i,j : 0<=i<6 /\ 0<=j<7 : A[i][j])}
[
   	VAR:
	A : array [0..6)x[0..7) of int;
	i : int;
	j : int;
	#nombreusuario:"Coloque su nombre, por favor:");
	#dificultad:"Seleccione la dificultad:(1=basico,2=medio)"

	i:=0;
	{bound 6-i}
	do i<6->
		j:=0;
		{bound 7-j}
		do j<7->
			A[i][j]:=0;
			j:=j+1;
		od
		i:=i+1;
	od
]

proc nuevapartida( in decision : bool ; in-out partida : int ; out jugando : bool )
{Pre: True}
{Post:irse=>jugando=False /\ not irse=>jugando=True}
[ 
	#se le pregunta al usuario si desea o no volver a jugar o no, esto
	#se almacena en la variable de entrada decision y cambia el valor
	#de jugando
	if decision->
		jugando:=True;
		partida:=partida+1;
	[] ¬decision->
		skip;                  #se sale del juego
	fi
]

proc resultados(in ganador, partida : int; out G: array [0..3) of int , out juega : bool) 
{Pre: ganador==0 \/ ganador==1 \/ ganador==2}
{Post: G[0]+G[1]+G[2]= partida-1}
[
	VAR:
	ganador:int;
	G: array [0..3) of int;				# la tabla de resultados se muestra al usuario
							# mientras no esta jugando
	if partida=1 ->
		G[0]:=-1;
		G[1]:=0;
		G[2]:=0;
	[] ganador=0->
		G[0]:=G[0]+1;
		juega := False;
	[] ganador=1->
		G[1]:=G[1]+1;
		juega := True;
	[] ganador=2->
		G[2]:=G[2]+1;
		juega := True;
	fi
]

proc abandonar(in irse: bool;in-out jugando: bool)
{Pre: jugando=True}
{Post: irse=>jugando=False /\ not irse=>jugando=True}
	#este procedimiento toma la decision del usuario, reflejada en la constante irse
	#y modifica el valor de jugando para terminar o continuar la partida
[
	if irse->
		jugando:=False;
	[] not irse->
		skip;
	fi
]

proc terminar(in rendirse: bool; in-out dentro: bool)
{Pre: dentro=True}
{Post: rendirse=>dentro=False /\ not rendirse=>dentro=True}
	#este procedimiento toma la decision del usuario, reflejada en la constante terminar
	#y modifica el valor dentro para salirse o no del programa 

	if rendirse->
		dentro:=False;
	[] not rendirse->
		skip;
	fi
]

proc IA(in-out i,j : int ; in-out A: array [0..6)x[0..7) of int)
{Pre: 0<=i<6 /\ 0<=j<7}
{Post: 0<=i<6 /\ 0<=j<7}
[
	VAR:					# para esta primera version de la IA solo nos interesan
	x:int;					# las que puede hacer a partir de la anterior, por lo que
	max:int;				# la vi(vertical inferior queda descartada), y tiende a
	hi,hd,vs,dps,dss: int;			# escoger jugadas horizontales.

	hi,hd,vs,dps,dpi,dss,dsi:=0,0,0,0,0,0,0;
								
	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea horizontal hacia la izquierda de su posicion
	do x<4 /\ valida(i,j-x) -> 	
		hi:= hi+1;		
		x:=x+1;
	od

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea horizontal hacia la derecha de su posicion
	do i<4 /\ valida(i,j+x)->
		hd:= hd+1;
		x:=x+1;
	od
	
	if valida(1+x,j)->		# aqui solo se cuenta si la proxima posible jugada para armar una
		vs := vs+1;		# linea vertical, justo arriba de su posicion
	[] not valida(1+x,j)->
		skip;
	fi;

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una	
	{bound 4-x}			# linea diagonal principal superior (raro pero posible)
	do x<4 /\ valida(i-x,j-x)->	 
		dps:= dps+1;
		x:=x+1;
	od;

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una	
	{bound 4-x}			# linea diagonal principal inferior (raro pero posible)                
	do x<4 /\ valida(i+x,j+x)->	 
		dpi:= dpi+1;
		x:=x+1;
	od;

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea diagonal secundaria superior (raro pero posible)
	do x<4 /\ valida(i-x,j+x)->
		dss:= dss+1;
		x:=x+1;
	od;
	
	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# diagonal secundaria inferior (raro pero posible)
	do x<4 /\ valida(i+x,j-x)->
		dsi:= dsi+1;
		x:=x+1;
	od;

	max:=max(hi,hd,vs,dps,dpi,dss,dsi);	# buscamos la jugada mas "favorable"
		if max=0->			# si la pieza se encuentra rodeada, se busca un nuevo
			i,j:=5,6;		# lugar donde jugar.
			{bound i}
			do 0 <= i < 6->
			{bound j}
				do  0 <= j < 7 ->
					if valida(i,j) ->
						A[i][j]:=2;
					[] !valida(i,j) ->
						skip
					fi
					j:=j-1
				od
				i:=i-1
			od
			
		[] max=hi->			# la ejecutamos
			A[i][j-1]:=2;
		[] max=hd->
			A[i][j+1]:=2;
		[]max=vs->
			A[i+1][j]:=2;
		[]max=dps->
			A[i][j+1]:=2;
		[]max=dpi->
			A[i][j+1]:=2;
		[]max=dss->
			A[i][j+1]:=2;
		[]max=dsi->				
			A[i][j+1]:=2;
		fi
# Se planea mejorar esta IA, para que reconozca si esta rodeada de jugadas aliadas o rivales
# de tal manera que pueda mejorar aun mas su criterio de decision.
# Posible nivel 3
]
