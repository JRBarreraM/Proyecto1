#
# Juego4enLineaEquipo07.gcl
#
# DESCRIPCION: algoritmo que permite a un usuario jugar al 4 en linea \
# contra una IA con 2 niveles de dificultad (facil y medio), a traves de la \
# terminal de la interfaz grafica.
#
# Autores: 
#	Br. Jose Barrera y Alfredo Cruz.
#
# Ultima modificacion: 16/03/2018.

[
   CONS					# las constantes nos ayudan a tener la informacion que no
   	nombre : str;			# podemos pedir al usuario, su nombre, la dificultad, 
	nivel : int;			# si desea abandonar una partida, si desea salir del programa,
	terminar : bool;		# y por supuesto la juga que hara en cada turno reflejada en
	irse : bool;			# sus coordenadas fila, columna.
	i : int;
	j : int;
   VAR
	A : array [0..6)x[0..7) of int;		# el tablero de juego
	jugando : bool;				# en partida
	turno : int;				# contador de los turnos 
	juega : int;				# a quien le toca jugar
	ganador : int;				# el primero en cumplir las condiciones
	dentro : bool;				# dentro del programa
	movida : bool;				# permite reintentar hasta hacer una jugada
	
	 
	{ %forall i,j: 0<=i<6 /\ 0<=j<7: S[i][j]=0 /\ (nivel=1 \/ nivel=2)}
		jugando,turno,ganador,juega,dentro:=False,1,0,True,True;
		{bound 43 - turno}
		do jugando /\ dentro ->							#en partida
			if turno = 42 ->
				jugando:=0
			[] turno < 42 ->
				if juega ->
					abandonar();
					jugadaUser(A,i,j);
					victoria();
				[] ¬juega ->
					if nivel = 1 ->
						movida:=True;
						do movida->
							i:=random.randrange(6);
							j:=random.randrange(7);
							if valida(A,i,j) ->
								A[i][j] := 2;
								movida := False;
							[] not valida(A,i,j) ->
								skip;
							fi;
						victoria();
					[] nivel = 2 ->
						if turno=1 \/ turno=2 ->
							primera();
						[] turno > 2 ->
							IA();
							victoria();
						fi
					fi
				turno := turno+1
				juega := ¬juega
				fi
			fi;

			if ganador = 0 ->
				juega := False; 
			[] ganador = 1 ->
				juega := True;
			[] ganador = 2 ->
				juega := True;
			fi

		[] ¬jugando /\ dentro ->							#en menu
			resultados( ganador );
			nuevapartida( decision );
			Inicio(A);
			terminar();
		od
   { ??? }
]

#Aqui termina el esqueleto del programa, de aqui en adelante se colocan
# todos los procedimientos que llama.

func jugadaUser( A : array [0..6)x[0..7) of int; i : int ; j : int)-> array [0..6)x[0..7) of int;
{ Pre: True }
{ Post:  (valida(i,j)=1 => A[i][j] = 1]) /\ (valida(i,j)=0 => A[i][j] = 0) }
[
	VAR
		ganador : int;
		jugando : int;

		ganador := 0;
		jugando := 0;

		if valida(i,j) ->
			A[i][j] := 1;
			victoria(A,i,j); 
		[] valida(i,j) ->
			skip
	>> A
]

# Esta es la funcion una de las funciones mas importantes del programa, sin importar
# si la coordenada esta o no en el tablero (la matriz A), nos dice si la jugada es valida
func valida( A : array [0..6)x[0..7); i,j : int ) -> bool
{ Pre: True }
{ Post: valida=((A[i][j]=0)/\i=5)\/((A[i][j]=0)/\i<5/\A[i-1][j]!=0)}
[
	VAR
	valida : bool;
	
	if 0 <= i < 6 /\ 0 <= j < 7 ->
		if A[i][j]=0 ->
			if i=5 ->
				valida:=True;
			[] i<5 /\ A[i-1][j]!=0 ->
				valida:=True;
			[] i<5 /\ A[i-1][j]=0 ->
				valida:=False;
			fi
		[] A[i][j]!=0 ->
			valida:=False;
		fi
	[] i < 0 \/ i > 5 \/ j < 0 \/ j > 6 ->
		valida:=False
	fi

	>> valida
]
		
proc victoria(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool)
{ Pre: True  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[

	victoriahorizontal(A,i,j);

	if jugando ->
		victoriavertical(A,i,j);
		if jugando ->
			victoriadiagonalprincipal(A,i,j);
			if jugando ->
				victoriadiagonalsecundaria(A,i,j)
			[] ¬jugando ->
				skip
		[] ¬jugando ->
			skip
		fi
	[] ¬jugando ->
		skip
	fi
]
#Aqui se verifican las distintas codiciones para que un jugador gane el juego formando 4 en raya.
proc victoriadiagonalprincipal(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[
	VAR
    	ganador : int;
		jugando : int;
		i : int;
		j : int;

	jugando := 1;

	i:=0;
	{bound 6-i}
	do i < 3 ->
		j:=0;
		{bound 4-j}
		do j < 4 /\ jugando=1 ->
			#Conexion diagonal principal
			if A[i][j]=A[i+1][j+1]=A[i+2][j+2]=A[i+3][j+3]=1 ->
				ganador:=1;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			
			[] A[i][j]=A[i+1][j+1]=A[i+2][j+2]=A[i+3][j+3]=2 ->
				ganador:=2;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi
			j:=j+1;
		od;
		i:=i+1;
	od;
]

proc victoriahorizontal( in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[
	VAR
    	ganador : int;
		jugando : int;
		i : int;
		j : int;

	jugando,i := 1,0;

	{bound 6-i}
	do i<6->
		j:=0;
		{bound 4-j}
		do j<4 and jugando=1->
			#Conexion horizontal
			[] A[i][j]=A[i][j+1]=A[i][j+2]=A[i][j+3]=1 ->
				ganador:=1;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			[] A[i][j]=A[i][j+1]=A[i][j+2]=A[i][j+3]=2 ->
				ganador:=2;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi
			j:=j+1;
		od
		i:=i+1;
	od
]

proc victoriavertical(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[
	VAR
    	ganador : int;
		jugando : int;
		i : int;
		j : int;

	jugando, i := 1,0;

	{bound 3-i}
	do i < 3 ->
		j:=0;
		{bound 7-j}
		do j < 7 /\ jugando=1 ->
			if A[i][j]=A[i+1][j]=A[i+2][j]=A[i+3][j]=1 ->
				ganador:=1;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			[] A[i][j]=A[i+1][j]=A[i+2][j]=A[i+3][j]=2:
				ganador:=2;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;
			fi;
			j:=j+1;
		od
		i:=i+1;
	od
]

proc victoriadiagonalsecundaria(in A : array [0..6)x[0..7); in i,j : int; out ganador:int; out jugando:bool )
{ Pre: N = 6 /\ M = 7  }
{ Post:  (ganador=0 /\ jugando=1) \/ ((ganador=1 \/ ganador=2)/\(jugando=0)) }
[
	VAR
    	ganador : int;
		jugando : int;
		i : int;
		j : int;

	jugando, i := 1, 0;

	{bound 3-i}
	do i < 3 ->
		j:=0;
		{bound 7-j}
		do j < 7 /\ jugando=1 ->
			#Conexion diagonal secundaria
			if j>2 /\ A[i][j]=A[i+1][j-1]=A[i+2][j-2]=A[i+3][j-3]=1 ->
				ganador:=1;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			[] j>2 /\ A[i][j]=A[i+1][j-1]=A[i+2][j-2]=A[i+3][j-3]=2 ->
				ganador:=2;
				jugando:=0;
				A[i][j],A[i+1][j+1],A[i+2][j+2],A[i+3][j+3]:=3,3,3,3;

			fi;
			j:=j+1
		od;
		i:=i+1;
	od
]
# Aqui culminan las verificaciones de las posibilidades de ganar el juego con un 4 en raya.

proc Inicio(in-out A: array [0..6)x[0..7) of int) 			#tambien arroja el nombre y la dificultad
{Pre:}
{Post:}
[
   	VAR:
	A : array [0..6)x[0..7) of int;
	#nombreusuario:"Coloque su nombre, por favor:");
	#dificultad:"Seleccione la dificultad:(1=basico,2=medio)"

	i:=0;
	{bound 6-i}
	do i<6->
		j:=0;
		{bound 7-j}
		do j<7->
			A[i][j]:=0;
			j:=j+1;
		od
		i:=i+1;
	od
]

proc nuevapartida( in nuevapartida : bool ; out jugando : bool )
{Pre:}
{Post:irse=>jugando=False /\ not irse=>jugando=True}
[ 
	#se le pregunta al usuario si desea o no volver a jugar o no, esto
	#se almacena en la variable de entrada decision y cambia el valor
	#de jugando
	if decision->
		jugando:=True;
	[] ¬decision->
		skip;                  #se sale del juego
	fi
]

proc resultados(in ganador:int; out G: array [0..2) of int) 
{Pre: ganador==0 \/ ganador==1 \/ ganador==2}
{Post: G[0]+G[1]+G[2]=}
[
	VAR:
	ganador:int;
	G: array [0..2) of int;				# esto se muestra al usuario mientras
							# mientras no esta jugando
	if ganador=0->
		G[0]:=G[0]+1;
	[] ganador=1->
		G[1]:=G[1]+1;
	[] ganador=2->
		G[2]:=G[2]+1;
	fi
]

proc abandonar(in irse: bool;in-out jugando: bool)
{Pre: jugando=True}
{Post: irse=>jugando=False /\ not irse=>jugando=True}
	#este procedimiento toma la decision del usuario, reflejada en la constante irse
	#y modifica el valor de jugando para terminar o continuar la partida
[
	if irse->
		jugando:=False;
	[] not irse->
		skip;
	fi
]

proc terminar(in terminar: bool; in-out dentro: bool)
{Pre: dentro=True}
{Post: terminar=>dentro=False /\ not terminar=>dentro=True}
	#este procedimiento toma la decision del usuario, reflejada en la constante terminar
	#y modifica el valor dentro para salirse o no del programa 

	if terminar->
		dentro:=False;
	[] not terminar->
		skip;
	fi
]

proc primera(in-out A: array [0..6)x[0..7) of int ; out i,j : int)
{Pre: True}
{Post: i=5 /\ ((A[5][3]=2 /\ j=3) \/ (A[5][2]=2 /\ j=2))}
[
	VAR
	i,j : int;
	
	if valida(5,3)->
		A[5][3]:=2
		i,j:=5,3;
	[] not valida(5,3)->
		A[5][2]:=2
		i,j:=5,2;
	fi
]

proc IA(in-out i,j : int ; in-out A: array [0..6)x[0..7) of int)
{Pre: 0<=i<6 /\ 0<=j<7}
{Post: 0<=i<6 /\ 0<=j<7}
[
	VAR:					# para esta primera version de la IA solo nos interesan
	x:int;					# las que puede hacer a partir de la anterior, por lo que
	max:int;				# la vi(vertical inferior queda descartada), y tiende a
	hi,hd,vs,dps,dss: int;			# escoger jugadas horizontales.

	hi,hd,vs,dps,dpi,dss,dsi:=0,0,0,0,0;	
								
	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea horizontal hacia la izquierda de su posicion
	do x<4 /\ valida(i,j-x) -> 	
		hi:= hi+1;		
		x:=x+1;
	od

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea horizontal hacia la derecha de su posicion
	do i<4 /\ valida(i,j+x)->
		hd:= hd+1;
		x:=x+1;
	od
	
	if valida(1+x,j)->		# aqui solo se cuenta si la proxima posible jugada para armar una
		vs := vs+1;		# linea vertical, justo arriba de su posicion
	[] not valida(1+x,j)->
		skip;
	fi;

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una	
	do x<4 /\ valida(i+x,j+x)->	# linea diagonal principal superior (raro pero posible) 
		dps:= dps+1;
		x:=x+1;
	od;

	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# linea diagonal secundaria superior (raro pero posible)
	do x<4 /\ if valida(i-x,j+x)->
		dss:= dss+1;
		x:=x+1;
	od;
	
	x:=1;				# aqui cuenta las 3 proximas posibles jugadas para armar una
	{bound 4-x}			# diagonal secundaria inferior (raro pero posible)
	do x<4 /\ valida(i+x,j-x)->
		dsi:= dsi+1;
		x:=x+1;
	od;

	max:=max(hi,hd,vs,dps,dpi,dss,dsi);	# buscamos la jugada mas "favorable"
		if max=0->			# si la pieza se encuentra rodeada, se busca un nuevo
			i,j:=5,6;		# lugar donde jugar.
			{bound i}
			do 0 <= i < 6->
			{bound j}
				do  0 <= j < 7 ->
					if valida(i,j) ->
						A[i][j]:=2;
					[] !valida(i,j) ->
						skip
					fi
					j:=j-1
				od
				i:=i-1
			od
			
		[] max=hi->			# la ejecutamos
			A[i][j-1]:=2;
		[] max=hd->
			A[i][j+1]:=2;
		[]max=vs->
			A[i+1][j]:=2;
		[]max=dps->
			A[i][j+1]:=2;
		[]max=dpi->
			A[i][j+1]:=2;
		[]max=dss->
			A[i][j+1]:=2;
		[]max=dsi->				
			A[i][j+1]:=2;
		fi
# Se planea mejorar esta IA, para que reconozca si esta rodeada de jugadas aliadas o rivales
# de tal manera que pueda mejorar aun mas su criterio de decision.
# Posible nivel 3
]
